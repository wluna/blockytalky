#!/usr/bin/env python

import time
import thread
import logging
import socket
import usercode
import pika
import atexit
import copy
from blockytalky_id import *
from message import *
import urllib2

logger = logging.getLogger(__name__)


def handle_logging(logger):
    # Set the logging level.
    handler = logging.handlers.RotatingFileHandler(filename='/home/pi/blockytalky/logs/user_script.log',
                                                   maxBytes=8192, backupCount=3)
    globalHandler = logging.handlers.RotatingFileHandler(filename='/home/pi/blockytalky/logs/master.log',
                                                         maxBytes=16384, backupCount=3)
    formatter = logging.Formatter(fmt='%(asctime)s - %(levelname)s: %(message)s',
                                  datefmt='%H:%M:%S %d/%m')
    handler.setFormatter(formatter)
    globalHandler.setFormatter(formatter)
    globalHandler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.addHandler(globalHandler)
    logger.setLevel(logging.INFO)
        

class UserScript(object):
    RUN_INTERVAL = 0.04 # how often to do the contents of "run_continuously"

    def __init__(self):
        logger.info('Initializing user script object')
       
        self.hostname = BlockyTalkyID()
        self.robot = Message.initStatus()
        self.last_robot = Message.initStatus()
        
        self.sensorStatus= Message.createSensorStatus()
        logger.debug(self.sensorStatus.values())

        self.hwval_channel = None
        self.hwcmd_channel = None
        
        self.MsgIn_channel = None
        self.MsgOut_channel = None

        parameters = pika.ConnectionParameters()
        self.connection = pika.BlockingConnection(parameters)
        
        self.setup_hwcmd_channel()
        self.setup_hwval_channel()      
        
        # initializes the list of callback functions for when you receive a 
        # sensor message
        self.callbacks = []
        self.init_callbacks()
   
    def start(self):
        self.run_on_start()
        self.schedule_run_continuously()
        self.hwval_channel.start_consuming()

    def schedule_run_continuously(self):
        self.connection.add_timeout(self.__class__.RUN_INTERVAL, self.run_cont_and_reschedule)   

    def run_cont_and_reschedule(self):
        self.run_continuously()
        self.schedule_run_continuously()


    def setup_hwcmd_channel(self):  
        self.hwcmd_channel = self.connection.channel()
        logger.info("Creating sensors exchange...")
        self.hwcmd_channel.exchange_declare(exchange='HwCmd', type='fanout')

    def setup_hwval_channel(self):
        self.hwval_channel = self.connection.channel()
        self.hwval_channel.exchange_declare(exchange='sensors', type='fanout')
        result = self.hwval_channel.queue_declare(exclusive=True)
        queue_name = result.method.queue
        self.hwval_channel.queue_bind(exchange='sensors', queue=queue_name)
        logger.info("Declaring HwVal callback...")
        self.hwval_channel.basic_consume(self.handle_hwval_delivery, queue=queue_name, no_ack=True)
    
  
    def handle_hwval_delivery(self, ch, method, properties, body):
        message = Message.decode(body)
        hwDict = message.getContent()
        logger.debug('Updating the robot status: %s' % str(hwDict))
        
        # update value changes
        for key, valueList in hwDict.iteritems():
            for index, value in enumerate(valueList):
                if value is not None:
                    self.robot[key][index] = value
                    
        # there is unread data on all ports
        for sensor in self.sensorStatus:
            self.sensorStatus[sensor] = True

        for callback in self.callbacks:
            callback()

        self.last_robot = copy.deepcopy(self.robot)
    



    #this will be generated by the user

    def run_on_start(self):
        print "running on start"

    def run_continuously(self):
        pass

    def on_sensor_change(self):
        print self.robot["sensors"]
        toSend = Message(self.hostname, None, "HwCmd", Message.createImage(motor2=-100))
        toSend = Message.encode(toSend)
        self.hwcmd_channel.basic_publish(exchange="HwCmd", routing_key="", body=toSend)
        time.sleep(.01)



# this could be a footer file or get tacked onto the user code in
# blockly webserver
if __name__ == "__main__": 

    handle_logging(logger)
    us = UserScript()
    us.start()
    
